#!/usr/bin/env fontforge -script

import sys
import os
import glob
import fontforge
import traceback # traceback 임포트
import logging

# --- 로깅 설정 ---
# 로깅 기본 설정: INFO 레벨 이상, 포맷 지정
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# --- 추가: 파일 핸들러 설정 (오류/경고를 별도 파일에 기록) ---
ERROR_LOG_FILE = "/app/fontforge_error.log" # 오류 로그 파일 경로 (컨테이너 내부)
# 시작 시 오류 로그 파일 초기화
if os.path.exists(ERROR_LOG_FILE):
    try: os.remove(ERROR_LOG_FILE)
    except OSError as e: logging.warning(f"기존 오류 로그 파일 삭제 실패: {e}")

file_handler = logging.FileHandler(ERROR_LOG_FILE)
file_handler.setLevel(logging.WARNING) # WARNING 레벨 이상만 파일에 기록
file_formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
file_handler.setFormatter(file_formatter)
logging.getLogger().addHandler(file_handler)

# 기본 폰트 속성 (인자로 재정의 가능)
DEFAULT_EM_SIZE = 1024 # FontForge 기본값은 1000이지만, 1024가 일반적
DEFAULT_ASCENT = 800   # 필요에 따라 조정
DEFAULT_DESCENT = 200  # 필요에 따라 조정

def get_char_from_filename(filename):
    """파일 이름에서 문자를 추출합니다 (예: '가.svg' -> '가')."""
    base = os.path.splitext(os.path.basename(filename))[0] # 파일 이름 (확장자 제외)
    # 파일 이름이 표준적이지 않을 경우 발생할 수 있는 UnicodeDecodeError 처리
    try:
        # 파일 이름 자체가 문자인 경우
        if len(base) == 1:
            return base
        # U+XXXX 형식이 있는 경우 처리 (예: U+AC00.svg)
        elif base.startswith("U+") and len(base) == 6:
             return chr(int(base[2:], 16)) # 16진수 코드포인트를 문자로 변환
    except Exception as e:
        # stderr 및 로그 파일에 경고 기록 시도 (이제 로거가 처리)
        logging.warning(f"파일 이름 '{filename}'에서 문자를 확인할 수 없습니다: {repr(e)}")
    return None # 실패 시 None 반환

def main(input_dir_abs, output_ttf_abs, font_name, family_name, style_name):
    """SVG 글리프에서 TTF 폰트를 생성하고, 디렉토리를 변경합니다."""

    original_dir = os.getcwd() # 원래 작업 디렉토리 저장
    logging.info(f"원래 작업 디렉토리: {original_dir}")
    logging.info(f"입력 SVG 디렉토리: {input_dir_abs}")
    logging.info(f"출력 TTF 경로 (기준): {output_ttf_abs}")

    # --- 폰트 생성 --- 
    font = fontforge.font()

    # EM 크기, 어센트, 디센트 먼저 설정
    font.em = DEFAULT_EM_SIZE
    font.ascent = DEFAULT_ASCENT
    font.descent = DEFAULT_DESCENT

    font.encoding = 'UnicodeFull' # 유니코드 인코딩 사용

    # --- 폰트 속성 설정 --- 
    font.fontname = font_name # 내부 PostScript 이름
    font.familyname = family_name # 패밀리 이름
    font.fullname = f"{family_name} {style_name}" # 전체 이름
    font.weight = "Regular" # 가중치 (필요시 style_name에서 파생)
    font.version = "1.0" # 버전
    font.copyright = "Generated by Pipeline" # 저작권 정보 (필요시 상세 정보 추가)

    logging.info(f"폰트 속성 설정됨 (EM: {font.em}, Ascent: {font.ascent}, Descent: {font.descent})")

    # --- 입력 디렉토리로 변경 --- 
    try:
        os.chdir(input_dir_abs)
        logging.info(f"작업 디렉토리를 변경함: {os.getcwd()}")
    except Exception as cd_err:
        logging.critical(f"오류: 디렉토리를 {input_dir_abs}(으)로 변경할 수 없습니다: {cd_err}")
        sys.exit(1)

    # --- 새 현재 디렉토리 기준으로 SVG 파일 찾기 --- 
    svg_files = glob.glob("*.svg") # 현재 디렉토리에서 SVG 파일 정의
    if not svg_files:
        logging.error(f"오류: {os.getcwd()}에서 SVG 파일을 찾을 수 없습니다.")
        os.chdir(original_dir) # 종료 전 원래 디렉토리로 돌아감
        sys.exit(1)

    # --- 루프 처리 복원 --- 
    # 이제 길이 출력
    logging.info(f"\n{os.getcwd()}에서 {len(svg_files)}개의 SVG 글리프를 가져옵니다...")

    imported_count = 0 # 가져온 글리프 수
    skipped_count = 0 # 건너뛴 글리프 수
    for svg_filename in svg_files: # 루프 복원
        char = get_char_from_filename(svg_filename)
        if char is None:
            skipped_count += 1
            continue

        glyph = None # 글리프 객체 초기화
        unicode_val = -1 # 유니코드 값 초기화
        try:
            logging.info(f"  처리 중 '{svg_filename}' (문자: '{char}')")
            unicode_val = ord(char) # 문자의 유니코드 값
            glyph = font.createChar(unicode_val) # 해당 유니코드 값으로 글리프 생성
            logging.info(f"    문자 생성됨 U+{unicode_val:04X}")

            # 현재 디렉토리에 있으므로 파일 이름만 사용하여 가져오기
            glyph.importOutlines(svg_filename)
            logging.info(f"    {svg_filename}에서 외곽선 가져옴")

            # 가져온 후 외곽선이 실제로 생성되었는지 확인
            if len(glyph.layers[glyph.activeLayer]) == 0:
                logging.warning(f"    경고: '{char}' ({svg_filename}) 가져온 후 외곽선을 찾을 수 없습니다. 건너뜁니다.")
                glyph.clear() # 글리프 내용 지우기
                skipped_count += 1
                continue # 다음 파일로 이동
            # 가져오기 후 처리 복원
            glyph.removeOverlap() # 겹침 제거
            glyph.correctDirection() # 방향 수정
            glyph.width = font.em # 글리프 너비 설정 (EM 크기)
            logging.info(f"    처리 완료 및 너비 설정됨: {glyph.width}")
            imported_count += 1 # 성공적으로 가져온 글리프 수 증가

        except Exception as e:
            # 표준 print를 사용하여 오류 출력 (로거로 변경)
            logging.error(f"***** 오류: 글리프 '{char}' (U+{unicode_val:04X} if unicode_val!=-1 else 'N/A') 처리 중 ({svg_filename}): {e} *****", exc_info=True)
            skipped_count += 1
            # 오류 발생 시 부분적으로 생성된 글리프 정리 확인
            if glyph is not None and unicode_val != -1 and unicode_val in font:
                try:
                     font.removeGlyph(glyph)
                     logging.info(f"오류 발생 후 부분 글리프 '{char}' 정리됨.")
                except Exception as remove_err:
                     logging.warning(f"부분 글리프 '{char}' 정리 중 오류: {remove_err}")


    # 루프에 대한 print 문 업데이트
    logging.info(f"\n가져오기 완료: {imported_count}개 글리프 가져옴, {skipped_count}개 건너뜀")

    # --- 폰트 파일 생성 --- 
    output_dir = os.path.dirname(output_ttf_abs) # TTF 경로에서 디렉토리 가져오기
    output_basename = os.path.splitext(os.path.basename(output_ttf_abs))[0] # 파일 이름 (확장자 제외)

    if not os.path.exists(output_dir):
        try:
            os.makedirs(output_dir)
            logging.info(f"출력 디렉토리 생성됨: {output_dir}")
        except Exception as mkdir_err:
             logging.critical(f"오류: 출력 디렉토리 {output_dir} 생성 불가: {mkdir_err}")
             os.chdir(original_dir) # 돌아가기 시도
             sys.exit(1)

    # 생성할 파일 확장자 리스트
    extensions = [".ttf", ".woff"]
    generated_files = []

    for ext in extensions:
        output_path = os.path.join(output_dir, output_basename + ext)
        logging.info(f"{ext.upper()} 파일 생성 중: {output_path}...")
        try:
            # TTF는 기본 flags=(), WOFF는 flags=('opentype',) 또는 flags=() 사용 가능
            # FontForge는 파일 확장자에 따라 적절한 포맷으로 생성 시도
            font.generate(output_path, flags=()) 
            logging.info(f"{ext.upper()} 생성 성공.")
            generated_files.append(output_path)
        except Exception as e:
            logging.error(f"오류: 폰트 파일 {output_path} 생성 실패: {e}", exc_info=True)
            skipped_count += 1
            # 오류 발생 시 계속 진행할지 아니면 종료할지 결정 (여기서는 계속 진행)

    # 원래 디렉토리로 돌아감
    os.chdir(original_dir)
    logging.info(f"작업 디렉토리를 {original_dir}(으)로 복원함")

    if not generated_files:
        logging.critical("*** 폰트 파일 생성 실패 ***")
        sys.exit(1)
    else:
        logging.info(f"\n생성된 파일: {', '.join(generated_files)}")

if __name__ == '__main__':
    # 인자 개수 확인
    if len(sys.argv) != 6:
        logging.critical("사용법: fontforge -script svg_to_ttf_converter.py <입력_svg_디렉토리> <출력_ttf_경로> <폰트_이름> <패밀리_이름> <스타일_이름>")
        sys.exit(1)

    # docker run에서 전달된 인자는 컨테이너 내부의 절대 경로
    input_dir = sys.argv[1]
    output_ttf = sys.argv[2]
    fontname = sys.argv[3]
    familyname = sys.argv[4]
    stylename = sys.argv[5]
    
    logging.info("SVG to TTF/WOFF 변환 스크립트 시작...")
    logging.info(f"  입력 디렉토리: {input_dir}")
    logging.info(f"  출력 TTF (기준): {output_ttf}")
    logging.info(f"  폰트 이름: {fontname}")
    logging.info(f"  패밀리 이름: {familyname}")
    logging.info(f"  스타일 이름: {stylename}")

    # 메인 함수 호출
    main(input_dir, output_ttf, fontname, familyname, stylename)
    
    logging.info("SVG to TTF/WOFF 변환 스크립트 완료.") 